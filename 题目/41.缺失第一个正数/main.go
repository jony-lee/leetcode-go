package main

//【题目】
/*
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

*/
//
//【思路】
/*
题目要求时间复杂度为O(n)，因此考虑只能是遍历常数遍，空间必须是O(1)，所以只能是原址操作，不能重新拷贝数组
只能通过数组本身来存储某个数是否存在的信息
查看了官方题解，最后看到的思路是通过索引的正负号来判断该数是否存在
因此，想了想就可以分为以下几步
先遍历判断1是否存在O(n),如果不存在，直接返回，如果存在，执行下一步
将所有负数和0全部替换成1（这样就将符号清理出来以便存储存在信息）
遍历数组O(n)，如果某个数存在，就把这个数的索引（此处要-1，让索引从0开始计算,并且要判断索引是否越界）对应的数组元素变成负数
最后遍历数组O(n)，找出第一个为正数的数，返回索引+1
如果完全遍历都没有，返回数组长度+1





*/

//【代码】
func firstMissingPositive(nums []int) int {
	//查找是否含有1
	for i := 0; i < len(nums); i++ {
		if nums[i] == 1 {
			break
		}
		if i == len(nums)-1 { //遍历后没有1，直接返回1
			return 1
		}
	}
	//将所有负数以及0置1
	for i := 0; i < len(nums); i++ {
		if nums[i] <= 0 {
			nums[i] = 1
		}
	}

	for i := 0; i < len(nums); i++ {
		temp := nums[i]
		if temp > len(nums) {
			continue
		}
		if temp < 0 {
			temp = temp * -1
		}
		if nums[temp-1] > 0 { //如果该数存在，则令其索引位置-1处置负（若本身为负，则不变）
			nums[temp-1] *= -1
		}
	}
	//找出第一个正数的位置
	for i := 0; i < len(nums); i++ {
		if nums[i] > 0 {
			return i + 1
		}
	}
	return len(nums) + 1
}

//【主函数】
func main() {

}

//【总结】：
/*







 */
